"""

NOTES ON THE VAN HATEREN IMAGE DATASET: 
http://bethgelab.org/datasets/vanhateren/
  * Only pixels within a two-pixel wide border around the image are guaranteed
    to be valid
  * Images seem to have a maximum value of 6282.0


Differences between *.imc and *.iml
-----------------------------------

(from http://bethgelab.org/datasets/vanhateren/)

The *.iml image set ('linear') are the raw images produced by the camera,
linearized with the lookup table generated by the camera for each image. The
images are slightly blurred by the point-spread function of the camera (in
particular due to the optics of the lens). For projects where a stricly linear
relationship between scene luminance and pixel values is important (e.g., when
looking at contrast variations over images) this may be the set of choice.

The *.imc image set ('calibrated') is computed from the *.iml set by
deconvolving the images with the point-spread function corresponding to the
used lens aperture (see the methods section of the article cited above). This
strongly reduces the blur at sharp edges and lines. The deconvolution
occasionally leads to overshoots and undershoots; the latter can produce
negative pixel values in a minority of images. For those images this was
compensated by adding a fixed offset to all pixel values of the image. These
offsets are listed below in the IMC offest list. Although they are generally
quite small, they slightly compromise the linearity of the relationship
between scene luminance and pixel value. Therefore this image set is best
suited for projects where well-defined edges are of more importance than
strict linearity.


Loading Patches
---------------

The van Hateren data set is typically used as a source of natural image
patches [citations needed, but see for example work on sparse coding and RBM
and autoencoder dictionary learning]

"""

# Copyright (C) 2012
# Authors: Eric Hunsberger, James Bergstra

# License: Simplified BSD

import hashlib
import os
import numpy as np

from skdata.data_home import get_data_home
from skdata.utils import download
from skdata.utils import random_patches


class Calibrated(object):
    """

    Attributes
    ----------

    self.meta - a list of dictionaries of the form
        {
        'basename': <something like 'imk04118.imc'>
        'md5': the desired md5 checksum for that file,
        'calibrated': True,
        'image_shape': (1024, 1536),
        'image_dtype': 'uint16'
        }

    """

    BASE_URL = 'http://pirsquared.org/research/vhatdb/imc/'

    imshape = (1024, 1536)

    def __init__(self, n_item_limit=None):
        self.name = self.__class__.__name__
        self.n_item_limit = n_item_limit

    def home(self, *suffix_paths):
        return os.path.join(get_data_home(), 'vanhateren', self.name,
                            *suffix_paths)

    @property
    def meta(self):
        if not hasattr(self, '_meta'):
            self.fetch(download_if_missing=True)
            self._meta = self._get_meta()
        return self._meta

    def _get_meta(self):
        meta = []
        for line in open(self.home('md5sums')):
            md5hash, basename = line.strip().split()
            basename = basename[1:]
            if 'HEADER' in basename:
                continue
            meta.append({'basename': basename,
                         'md5': md5hash,
                         'calibrated': True,
                         'image_shape': (1024, 1536),
                         'image_dtype': 'uint16',
                        })
        return meta

    def fetch(self, download_if_missing=True):
        if not download_if_missing:
            return
        if not os.path.exists(self.home()):
            os.makedirs(self.home())

        def checkmd5md5():
            md5sums = open(self.home('md5sums'), 'rb').read()
            md5md5 = hashlib.md5(md5sums).hexdigest()
            if md5md5 != 'da55092603cb2628e91e759aec79f654':
                print 'Re-downloading corrupt md5sums file'
                download(self.BASE_URL + 'md5sums', self.home('md5sums'))
        try:
            checkmd5md5()
        except IOError:
            download(self.BASE_URL + 'md5sums', self.home('md5sums'))
            checkmd5md5()

        meta = self._get_meta()
        for ii, item in enumerate(meta):
            if self.n_item_limit is None:
                required = True
            else:
                required = ii < self.n_item_limit
            try:
                data = open(self.home(item['basename']), 'rb').read()
                if hashlib.md5(data).hexdigest() != item['md5']:
                    # -- ignore 'required' flag for incorrect files
                    print 'Re-downloading incorrect file', item['basename']
                    download(self.BASE_URL + item['basename'],
                             self.home(item['basename']),
                             md5=item['md5'])
                    # TODO: catch ctrl-C, check md5,
                    # and remove partial download
            except IOError:
                if required:
                    download(self.BASE_URL + item['basename'],
                             self.home(item['basename']),
                             md5=item['md5'])

    def read_image(self, item):
        """Return one image from the Van Hateren image dataset

        Returns a (1024, 1536) in the original uint16 dtype
        """
        assert item['image_dtype'] == 'uint16'

        filename = os.path.join(self.home(item['basename']))
        s = open(filename, 'rb').read()
        assert hashlib.md5(s).hexdigest() == item['md5']
        img = np.fromstring(s, dtype=item['image_dtype']).byteswap()
        img = img.reshape(item['image_shape'])
        return img

    def raw_patches(self, rshape, rng=None, items=None):
        """Return random patches drawn randomly from natural images

        Parameters
        ----------
        rshape - tuple (N, rows, cols)
            The shape of the returned ndarray

        rng - np.RandomState
            RandomState

        items - None or items from self.meta
            A list of images from which to draw patches

        """
        if rng is None:
            rng = np.random
        if items is None:
            items = self.meta
        N, prows, pcols = rshape

        images = np.asarray(map(self.read_image, items))

        rval4 = random_patches(images[:, :, :, None], N, prows, pcols, rng)
        return rval4[:, :, :, 0]

